## 클로저: 환경을 캡처할 수 있는 익명 함수

러스트의 *클로저*는 변수에 저장하거나 다른 함수에 인자로 넘길 수 
있는 익명 함수입니다. 한 곳에서 클로저를 만들고 다른 문맥에서 
그것을 평가하기 위해 호출할 수 있습니다. 함수와 다르게 클로저는 
정의된 스코프에서 값을 캡처할 수 있습니다. 앞으로 클로저의 이러한 
기능이 코드 재사용과 동작 사용자 정의를 어떻게 가능케 하는지 살펴볼 
것입니다.

### 클로저로 동작을 추상화하기

클로저를 나중에 실행하기 위해 저장하는 것이 유용한 상황에 대한 
예제로 시작해봅시다. 이 과정에서 클로저 문법과 타입 추론, 
트레잇에 관해 얘기합니다.

이런 가상의 상황을 생각해 봅시다: 우리는 맞춤 운동 계획을 생성하는 
앱을 만드는 스타트업에서 일합니다. 백엔드는 러스트로 작성되어 있고, 
운동 계획을 생성하는 알고리즘은 사용자의 나이, 체질량 지수, 선호 운동, 
최근 운동, 사용자가 설정한 운동 강도 등 여러 요소를 고려합니다. 
실제 알고리즘은 이 예제에서 그렇게 중요하지 않습니다. 중요한 것은 
이 계산에 몇 초씩이나 걸린다는 것입니다. 이 알고리즘을 우리가 필요할 
때 한 번만 호출하기를 원하고, 그래서 사용자가 필요 이상으로 기다리지 
않게 만들고 싶습니다.

우리는 리스트 13-1 에 보이는 `simulated_expensive_calculation` 
함수를 사용해서 이 가상의 알고리즘 호출을 시뮬레이션합니다. 이 함수는 
`calculating slowly...` 를 출력하고, 2초를 기다린 다음, 
인자로 넘어온 어떤 숫자든 돌려줍니다:

<span class="filename">파일명: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-01/src/main.rs:here}}
```

<span class="caption">리스트 13-1: 실행시간이 약 2초 걸리는 가상의 계산을 대신하는
함수</span>

다음은 이 예제에서 중요한 운동 앱의 일부를 담고 있는 `main` 
함수입니다. 이 함수는 사용자가 운동 계획을 요청할 때 앱이 
호출할 코드를 나타냅니다. 앱의 프론트엔드와의 상호작용은 
클로저 사용과 관련이 없기 때문에 프로그램에 대한 입력을 
나타내는 값을 하드코딩한 다음 결과를 출력할 것입니다.

필요한 입력들은:

* 낮은 강도 운동을 원하는지 혹은 고강도 운동을 원하는지를 
  나타내기 위해 사용자가 지정하는 *운동 강도 숫자*
* 몇 가지 다양한 운동 계획들을 생성할 *임의의 숫자*

출력은 추천 운동 계획이 될 것입니다. 리스트 13-2 는 
우리가 사용할 `main` 함수입니다.

<span class="filename">파일이름: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-02/src/main.rs:here}}
```

<span class="caption">리스트 13-2:`main` 함수와 사용자 입력과 임의의 숫자 생성을 시뮬레이션
하기 위한 하드코딩된 값</span>

단순함을 위해서 `simulated_user_specified_value` 변수의 
값을 10으로 하고 `simulated_random_number` 변수의 값을 
7로 하드코딩 했습니다. 실제 프로그램에서는 운동 강도를 프론트엔드에서 
전달받고 2장의 추리 게임에서처럼 난수 생성을 위해 `rand` 크레이트를 
사용할 것입니다. `main` 함수는 `generate_workout` 함수를 
모의의 입력값으로 호출합니다.

이제 상황이 만들어졌으니, 알고리즘으로 넘어가겠습니다. 리스트 13-3 
에 있는 `generate_workout` 함수는 이 예제에서 가장 신경 써야 
할 앱의 비즈니스 로직을 포함하고 있습니다. 이 예제에서 나머지 코드 
변경 사항은 이 함수에 적용됩니다:

<span class="filename">파일이름: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-03/src/main.rs:here}}
```

<span class="caption">리스트 13-3: 입력값과 `simulated_expensive_calculation` 함
수 호출에 따라 운동 계획을 출력하는 비즈니스 로직</span>

리스트 13-3 의 코드는 느린 계산 함수를 여러 번 호출합니다.
첫 번째 `if` 블록은 `simulated_expensive_calculation` 함수를 두 번 호출하고,
바깥 `else` 의 안쪽에 있는 `if` 문에서는 전혀 호출하지 않으며, 두 번째 `else` 문
의 경우는 한 번 호출합니다.

`generate_workout` 함수의 바람직한 동작은 먼저 사용자가 
저강도 운동(25보다 작은 수로 표시) 혹은 고강도 운동(25 이상의 
수)을 원하는지 판단하는 것입니다.

저강도 운동 계획은 우리가 시뮬레이션 하는 복잡한 알고리즘에 따라 팔굽혀펴기와
윗몸일으키기의 횟수를 추천합니다.

사용자가 고강도 운동을 원한다면, 약간의 추가 로직이 있습니다: 
앱에서 생성된 난수값이 3인 경우, 앱은 휴식과 수분 섭취를 추천합니다. 
그렇지 않은 경우, 사용자는 복잡한 알고리즘을 기반으로 선택된 시간(분) 
동안 달리기를 하도록 안내받습니다.

현재 코드는 우리가 원하는 대로 동작하고 있습니다. 하지만 한번 데이터 사이언스 팀이 
앞으로 `simulated_expensive_calculation` 함수를 호출하는 방식을 바꾸기로 
결정했다고 생각해 봅시다.
이러한 변경이 발생했을 때 업데이트를 단순화하기 위해서, 이 코드를 리팩토링하여 
`simulated_expensive_calculation` 함수를 딱 한 번만 호출하도록 하려고
합니다. 또한 현재 해당 함수를 같은 값을 인자로 해서 불필요하게 두 번 호출하는 
부분도 없애고 싶습니다. 즉, 결과가 필요 없다면 함수를 호출하고 싶지 않고, 
필요하더라도 딱 한 번만 호출하고 싶습니다.

#### 함수를 사용해서 리팩토링하기

우리는 여러 방법으로 운동 프로그램을 재구성할 수 있습니다. 우선, 리스트 13-4 에 
보이는 것처럼 중복된 `simulated_expensive_calculation` 함수 호출을 
하나의 변수로 추출해 볼 것입니다:

<span class="filename">파일이름: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-04/src/main.rs:here}}
```

<span class="caption">리스트 13-4: `simulated_expensive_calculation` 에 대한
호출들을 한 곳으로 추출하고 결과를 `expensive_result` 변수에 저장하기</span>

이 변경은 `simulated_expensive_calculation` 에 대한 모든 호출들을 
하나로 합치고 첫 번째 `if` 문에서 불필요하게 이 함수를 여러 번 호출하던 
문제를 해결합니다. 안타깝게도 이제 모든 경우에 대해서 이 함수를 호출하고 
결과를 기다리게 됩니다. 이 결과를 전혀 사용하지 않는 안쪽 `if` 블록의 
경우에도 이 함수 호출의 영향을 받게 됩니다.

우리는 프로그램에서 한 곳에서 코드를 정의하고, 실제로 결과가 필요한 곳에서만
그 코드를 *실행하고* 싶습니다. 이것이 클로저의 유스 케이스입니다.

#### 코드를 저장하기 위해 클로저를 사용해서 리팩토링하기.

`if` 블록 전에 항상 `simulated_expensive_calculation` 함수를 
호출하는 대신, 리스트 13-5에 보이는 것처럼 클로저를 정의하고 변수에 
함수 리턴 값을 저장하기보단 *클로저*를 저장할 수 있습니다. 
여기서 소개하는 것처럼 실제로 클로저 안에 `simulated_expensive_calculation` 
의 전체 내용을 옮길 수 있습니다.

<span class="filename">파일이름: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-05/src/main.rs:here}}
```

<span class="caption">리스트 13-5: 클로저를 정의하고 `expensive_closure` 변수에
저장하기</span>

클로저 정의는 변수 `expensive_closure` 에 할당하기 위해 `=` 
다음에 옵니다. 클로저 정의는 수직의 파이프 (`|`) 한 쌍으로 시작하며, 
그 사이에는 매개변수를 적습니다; 이 문법은 스몰토크와 루비에서 클로저 
정의와 비슷하여 선택되었습니다. 이 클로저는 `num` 이라는 하나의 
매개변수를 갖습니다: 하나 이상의 매개변수를 갖는다면, `|param1, param2|` 
와 같이 콤마로 구분합니다.

매개변수 다음에는 클로저의 몸통을 포함하는 중괄호를 넣습니다. 클로저 
몸통이 하나의 표현식이면 중괄호는 선택 사항입니다. 중괄호 다음에 
클로저의 끝에는 `let`문을 완성하기 위해 세미콜론이 필요합니다. 클로저 
몸통에서 마지막 줄의 (`num`) 은 클로저가 호출되었을 때 클로저로부터 
반환되는 값입니다. 왜냐하면 해당 라인은 함수에서처럼 세미콜론으로 
끝나지 않기 때문입니다.

`let` 문은 `expensive_closure` 가 익명함수의 *정의*를 포함하지, 
호출한 *결괏값*을 포함하지는 않는다는 것에 유의하세요. 우리가 클로저를 
사용하는 이유는 호출할 코드를 한 곳에서 정의하고 저장한 뒤에, 이후 
다른 곳에서 그것을 호출하길 원하기 때문이라는 것을 기억하세요; 우리가 
호출하고자 하는 코드는 이제 `expensive_closure` 에 저장되었습니다.

클로저를 정의한 후에는 `if` 블록 안의 코드는 클로저를 호출해서 결괏값을 
얻는 식으로 코드를 바꿀 수 있습니다. 함수를 호출하는 것처럼 클로저를 
호출합니다: 리스트 13-6 에 보이는 것처럼, 클로저 정의를 저장하는 
변수명을 적고 다음엔 사용할 인자값을 포함하는 괄호가 따라옵니다:

<span class="filename">파일명: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-06/src/main.rs:here}}
```

<span class="caption">리스트 13-6: 우리가 정의한 `expensive_closure` 호출하기
</span>

이제 비용이 큰 계산은 단 한 곳에서만 호출되고, 우리가 결과가 필요한 곳에서만
그 코드를 실행합니다.

그러나, 이는 리스트 13-3 에 있는 문제중 하나를 다시 야기하게 됩니다: 
우리는 여전히 첫 번째 `if` 블록에서 클로저를 두 번 호출 하는데, 
이는 비용이 큰 코드를 두 번 반복해서 호출하게 되면서 사용자는 두 배 
더 기다리게 됩니다. `if` 블록 안에 클로저 호출의 결과를 저장하는 
지역 변수를 만들어서 문제를 해결할 수도 있지만, 클로저는 다른 해결책을 
제공합니다. 그 해결책에 관해서는 조금 이따가 얘기하도록 하고 우선 
클로저 정의에 타입 어노테이션이 없는 이유와 클로저와 연관된 트레잇에 
관해 이야기 합시다.

### 클로저 타입 추론과 어노테이션

클로저는 `fn` 함수처럼 파라미터나 반환 값의 타입을 명시할 것을 
요구하지 않습니다. 타입 어노테이션은 사용자에게 노출되는 명시적인 
인터페이스의 일부이기 때문에 함수에 필요합니다. 이 인터페이스를 
엄격하게 정의하는 것은 함수가 어떤 타입의 값을 사용하고 반환하는지에 
대해 모두가 합의한다는 것을 보장하는 데 중요합니다.
그러나 클로저는 이처럼 노출된 인터페이스에 사용되지 않습니다: 변수에 저장되고
이름 없이 우리의 라이브러리 사용자들에게 노출되지 않고 사용됩니다.

추가로, 클로저는 보통 짧고 임의의 시나리오 보다 좁은 문맥 
안에서만 관련이 있습니다. 이런 제한된 문맥 안에서만, 
컴파일러는 안정적으로 파라미터와 리턴타입을 추론할 수 있으며, 
이는 대부분의 변수 타입을 추론하는 방법과 비슷합니다.

프로그래머들에게 이런 작고 익명의 함수들에 타입을 달도록 하는 
것은 짜증이 나고 컴파일러가 이미 사용할 수 있는 정보와 
대개 중복됩니다.

변수와 마찬가지로 필요 이상으로 자세히 표현하는 비용을 지불하고서라도
명확성과 명료성을 높이고 싶다면 타입 어노테이션(혹은 타입 명시)를 추가할 수 있습니다.
리스트 13-5 에 정의한 클로저에 타입을 명시하는 것은 리스트 13-7 에 보이는 것과
같을 것입니다:

<span class="filename">파일명: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-07/src/main.rs:here}}
```

<span class="caption">리스트 13-7: 클로저에 매개변수와 반환 값 타입에 대한 선택적
인 타입 어노테이션 추가하기</span>

타입 어노테이션이 있으면 클로저와 함수의 문법은 더 비슷해 보입니다.
다음은 매개변수에 1을 더하는 함수 정의와 동일한 행위를 하는 클로저를 
수직으로 비교한 것입니다. 관련 있는 부분들을 같은 위치에 놓기 위해 
약간의 공백을 추가했습니다. 이것은 파이프를 사용하는 것과 선택적인 
문법의 양을 무시하고 클로저 문법과 함수 문법이 얼마나 비슷한지 보여줍니다:

```rust,ignore
fn  add_one_v1   (x: u32) -> u32 { x + 1 }
let add_one_v2 = |x: u32| -> u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;
```

첫 번째 줄은 함수 정의를 보여주고, 두 번째 줄은 타입을 모두 
명기한 클로저 정의를 보여 줍니다. 세 번째 줄은 클로저 정의에서 
타입 어노테이션을 지웠고, 네 번째 줄은 선택적인 중괄호를 지웠는데, 
클로저 몸통이 단 하나의 표현식을 갖기 때문입니다.
이것은 모두 호출 했을 때 동일한 동작을 가지는 유효한 정의들입니다. 
`add_one_v3`와 `add_one_v4`의 경우에는 클로저 호출이 필요합니다. 
왜냐하면 어떻게 호출되는지에 따라 타입이 추론되기 때문입니다.

클로저 정의는 각각의 파라미터들과 반환 값에 대해 단 하나의 추론된 
구체적인 타입을 갖습니다. 예를 들면, 리스트 13-8 은 파라미터로 
받은 값을 그대로 반환하는 짧은 클로저의 정의를 보여줍니다. 이 클로저는 
이 예제의 목적 외에는 유용하지 않습니다. 정의에 타입 어노테이션을 
추가하지 않았다는 것에 유의하세요: 클로저를 두 번 호출하는데, 
첫 번째는 `String` 을 인자로 사용하고 두 번째는 `u32` 를 사용한다면 
에러가 발생합니다:

<span class="filename">파일명: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-08/src/main.rs:here}}
```

<span class="caption">리스트 13-8: 서로 다른 두 개의 타입으로 추론된 타입을 갖는 
클로저 호출해 보기</span>

컴파일러는 이런 에러를 줍니다:

```console
{{#include ../listings/ch13-functional-features/listing-13-08/output.txt}}
```

처음 `String` 값으로 `example_closure` 을 호출하면, 컴파일러는 `x` 의 타입과
클로저의 반환 타입을 `String` 으로 추론합니다. 그다음부터 `example_closure`의 타입은 `String`
으로 고정되고, 같은 클로저를 다른 타입으로 사용하려고 할 때 타입 에러를 얻게 됩니다.

### 제네릭 파라미터와 `Fn` 트레잇을 사용하여 클로저 저장하기

운동 생성 앱으로 돌아갑시다. 리스트 13-6 에서, 우리의 코드는 
아직도 비용이 큰 계산을 수행하는 클로저를 필요보다 더 많이 호출 
합니다. 이 문제를 풀기 위한 한 가지 옵션은 비용이 많이 드는 
클로저의 결괏값은 재활용을 위해 변수에 저장하고 후에 결과가
필요한 부분에서 클로저를 다시 호출하는 대신 그 변수를 사용하는 것입니다.
그러나, 이 방법은 많은 반복된 코드를 만들 수 있습니다.

다행히도 다른 해결책이 있습니다. 우리는 클로저와 클로저를 
호출한 결괏값을 가진 구조체를 만들 수 있습니다. 그 구조체는 
결괏값을 필요할 때만 클로저를 호출할 것이며 그 결괏값을 
캐싱해둬서 나머지 코드에서 결과를 저장하고 재사용하지 않아도 
되도록 할 것입니다. 이 패턴을 *메모이제이션(memoization)* 
혹은 *지연 평가(lazy evaluation)*로 알고 있을 것입니다.

구조체에서 클로저를 갖고 있도록 하기 위해, 클로저 타입을 기술할 필요가 있는데,
구조체 정의는 각 필드의 타입을 알 필요가 있기 때문입니다. 각 클로저 인스턴스는
자신의 유일한 익명 타입을 갖습니다: 즉, 두 클로저가 동일한 타입 서명을 갖더라도
그들의 타입은 여전히 다른 것으로 간주 됩니다. 클로저를 사용하는 구조체, 열거형,
함수 파라미터를 정의하기 위해, 10장에서 설명한 것처럼 제네릭과 트레잇 바운드를
사용합니다.

`Fn` 트레잇은 표준 라이브러리에서 제공합니다. 모든 클로저는 
다음 트레잇 중 하나를 구현합니다: `Fn`, `FnMut`, 혹은 
`FnOnce`. ["클로저로 환경 캡처 하기"](#클로저로-환경-캡처-하기)절에서 
이 트레잇들의 차이점들에 관한 설명할 것입니다; 이 예제에서 우리는 
`Fn` 트레잇을 사용할 수 있습니다.

클로저의 파라미터와 반환 값의 타입을 표현하기 위해 `Fn` 트레잇 
바운드에 타입을 추가합니다. 예제의 경우 클로저는 파라미터 타입이 
`u32`이고 `u32` 타입을 반환하므로, 명시하는 트레잇 바운드는 
`Fn(u32) -> u32` 입니다.

리스트 13-9 는 클로저와 선택적인 결괏값을 가진 `Cacher` 구조체의 
정의를 보여줍니다:

<span class="filename">파일명: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-09/src/main.rs:here}}
```

<span class="caption">리스트 13-9: `calculation` 에 클로저를 담고, 선택적인 결괏값을
`value` 에 담는 `Cacher` 구조체 정의하기</span>

`Cacher` 구조체는 제네릭 타입 `T` 의 `calculation` 필드를 갖습니다.
`T` 에 대한 트레잇 바운드는 `Fn` 트레잇을 사용하여 그것이 클로저라는 것을 나타냅니다. 
`calculation` 필드에 저장하고자 하는 클로저는 하나의 `u32` 타입 파라미터
(`Fn` 다음 괄호 안에 명시됨)를 갖고 `u32` (`->` 다음에 명시됨) 타입의 값을
반환해야 합니다.

> 노트: 함수는 세 개의 `Fn` 트레잇도 모두 구현할 수 있습니다. 
> 환경에서 값을 캡처할 필요가 없다면, `Fn` 트레잇을 구현해야 
> 하는 클로저 대신 함수를 사용할 수 있습니다.

`value` 필드는 `Option<u32>` 타입입니다. 클로저를 실행하기 
전에 `value` 의 값은 `None` 입니다. `Cacher` 를 사용하는 
코드에서 클로저의 *결과* 를 요청할 경우, `Cacher` 는 그때 
클로저를 실행하고 결과를 `Some` variant에 넣어서 `value`
필드에 저장합니다. 그다음부터는 코드에서 클로저의 결과를 다시 요청하면 클로저를 다시 
실행하는 대신, `Cacher` 는 `Some` variant 안에 있는 결과를 돌려줍니다.

방금 설명한 `value` 필드에 대한 로직은 리스트 13-10 에 
정의되어 있습니다: 

<span class="filename">파일명: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-10/src/main.rs:here}}
```

<span class="caption">리스트 13-10: `Cacher` 의 캐싱 로직</span>

우리는 호출하는 코드에서 구조체 필드의 값을 변경할 수 있게 
만드는 것보다는 `Cacher` 가 값을 관리하도록 하고 싶기 
때문에, 필드는 비공개(private) 입니다.

`Cacher::new` 함수는 제네릭 파라미터 `T` 를 받는데, 
`Cacher` 구조체와 동일한 트레잇 바운드를 갖도록 정의되었습니다. 
그다음 `Cacher::new` 는 `calculation` 필드에는 명시된 클로저를, 
`value` 필드에는 클로저를 아직 실행한 적이 없기 때문에 `None` 을 
갖는 `Cacher` 인스턴스를 반환합니다.

호출하는 코드에서 클로저를 평가한 결괏값을 원하면, 클로저를 
직접 호출하기보다 `value` 메서드를 호출합니다. 이 메서드는 
이미 `self.value` 에 결괏값을 `Some` 으로 가졌는지 
체크하고 만약 그렇다면 클로저를 다시 실행하는 대신 `Some` 안에 
있는 값을 반환합니다.

만약 `self.value` 가 `None` 이라면, `self.calculation` 에 
저장된 클로저를 호출하고, 나중에 재사용을 위해 결과를 `self.value` 에 
저장한 후 값을 반환합니다.

리스트 13-11 는 리스트 13-6 의 `generate_workout` 함수에서 `Cacher` 구조
체를 사용하는 방법을 보여줍니다:

<span class="filename">파일명: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-11/src/main.rs:here}}
```

<span class="caption">리스트 13-11: 캐싱 로직을 추상화하기 위해
`generate_workout` 함수 안에서 `Cacher` 사용하기</span>

클로저를 변수에 직접 저장하는 대신, 클로저를 갖는 `Cacher` 의 
새 인스턴스를 저장했습니다. 그러고는, 결과가 필요한 각 위치에 
`Cacher` 인스턴스의 `value` 메소드를 호출했습니다. 우리는 
`value` 메소드를 원하는 만큼 호출할 수 있고, 전혀 호출하지 
않을 수도 있으며, 비싼 계산은 최대 한 번만 수행될 것입니다.

리스트 13-2 의 `main` 함수로 이 프로그램을 실행해 보세요. 
다양한 `if` 와 `else` 블록에 있는 모든 케이스를 검증하기 위해 
`simulated_user_specified_value` 와 `simulated_random_number` 
변수들을 변경해 보세요. `calculating slowly...` 메세지는 단 한 번만, 
그리고 필요할 때만 나타납니다. `Cacher` 는 `generate_workout` 가
비즈니스 로직에 집중할 수 있도록 비싼 계산을 필요한 것보다 더 호출하지 
않도록 보장하는 필요한 로직을 처리합니다.

### `Cacher` 구현의 제약사항

값을 캐싱하는 것은 일반적으로 유용한 동작이기 때문에 다른 클로저와 함께 
코드의 다른 부분에서 사용하고 싶을 수도 있습니다. 그러나 현재 `Cacher`
구현은 다른 문맥에서 다르게 재사용하기에는 두 가지 문제가 있습니다.

첫 번째 문제는 `Cacher` 인스턴스가 `value` 메소드의 `arg` 
파라미터는 항상 같은 값을 얻는다는 가정을 한다는 것입니다. 
즉, 이 `Cacher` 테스트는 실패할 것입니다:

```rust,ignore,panics
{{#rustdoc_include ../listings/ch13-functional-features/no-listing-01-failing-cacher-test/src/lib.rs:here}}
```

이 테스트는 인자로 받은 값을 그대로 돌려주는 클로저가 포함된 새로운 `Cacher`
인스턴스를 생성합니다. `arg` 값을 1로 그리고 `arg` 값을 2로 해서 이 `Cacher`
인스턴스의 `value` 메소드를 호출하고, `arg` 값을 2로 `value` 를 호출 했을 때
2를 반환 할 것으로 기대합니다.

리스트 13-9 와 13-10 에 있는 `Cacher` 구현에 대해 이 테스트를 돌리면, 테스트는
다음과 같은 메시지와 함께 `assert_eq!` 에서 실패할 것입니다:

```console
{{#include ../listings/ch13-functional-features/no-listing-01-failing-cacher-test/output.txt}}
```

문제는 처음 `c.value` 을 1로 호출 했을 때, `Cacher` 인스턴스는 `self.value` 에
`Some(1)` 을 저장합니다. 그 후에, `value` 값으로 무엇을 넘기던 메소드는 항상 1을 
반환할 것입니다.

`Cacher` 가 하나의 값 대신 해시맵을 사용하도록 수정해 봅시다. 
해시맵의 키는 넘겨받은 `arg` 값이 될 것이고, 해시맵의 값은 
그 키로 클로저를 호출한 결과가 될 것입니다. `self.value` 가 
`Some` 혹은 `None` 값인지 직접 살펴보는 대신, `value` 함수는 
해시맵의 `arg` 값을 살펴보고 값이 있으면 반환할 것입니다.
값이 없으면, `Cacher` 는 클로저를 호출해서 해당 `arg` 값과 연관된 해시맵에
결괏값을 저장할 것입니다.

현재 `Cacher` 구현의 두 번째 문제는 `u32` 타입 파라미터 
한 개만 받고 하나의 `u32` 을 반환한다는 것입니다. 예를 들면, 
문자열 슬라이스를 넘겨주고 `usize` 값을 반환하는 클로저의 
결과를 캐시에 저장하고 싶을 수도 있습니다. 이 이슈를 수정하기 위해, 
`Cacher` 기능에 유연성을 높여주도록 더 제네릭한 파라미터를 사용해 봅시다.

### 클로저로 환경 캡처하기

운동 생성 예제에서 우리는 클로저를 단지 인라인 익명 
함수로 사용했습니다. 그러나 클로저는 함수에 없는 
추가적인 능력을 갖추고 있습니다: 환경을 캡처해서
클로저가 정의된 스코프의 변수에 접근할 수 있습니다.

리스트 13-12 는 `equal_to_x` 변수에 저장된 클로저가 클로저를 둘러싼 환경에 있는 `x` 변수를
사용하는 예제를 보여줍니다:

<span class="filename">파일명: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-12/src/main.rs}}
```

<span class="caption">리스트 13-12: 둘러싼 스코프에 있는 변수를 참조하는 클로저의
예</span>

비록 `x` 가 `equal_to_x` 의 파라미터 중의 하나가 
아니더라도, `equal_to_x` 는 동일한 스코프에 정의된 
`x` 변수를 사용하는 것이 허용됩니다.

함수로는 이와 동일하게 할 수 없습니다; 다음 예제로 시도해 보면, 코드는 컴파일
되지 않습니다:

<span class="filename">파일명: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch13-functional-features/no-listing-02-functions-cant-capture/src/main.rs}}
```

에러가 발생합니다:

```console
{{#include ../listings/ch13-functional-features/no-listing-02-functions-cant-capture/output.txt}}
```

컴파일러는 이것은 클로저에서만 동작한다고 상기시켜 주기까지 합니다!

클로저가 환경으로부터 값을 캡처할 때, 클로저 몸통에서 사용하기 위해 그 값을
저장하기 위한 메모리를 사용합니다. 이 메모리 사용은 환경을 캡처하지 않는 코드를
실행하길 원하는 더 흔한 상황에서는 지불하고 싶지 않은 오버헤드입니다.
왜냐하면 함수는 환경을 캡처할 수 없기 때문에, 함수를 정의하고 사용하는데
절대 이런 오버헤드는 발생하지 않습니다.

클로저는 세 가지 방식으로 환경으로부터 값을 캡처할 수 있는데, 
함수가 파라미터를 받는 세 가지 방식과 직접적으로 연결됩니다: 
소유권 받기, 가변으로 빌려오기, 불변으로 빌려오기. 이들은 
다음과 같이 세 가지의 `Fn` 트레잇으로 표현합니다:

* `FnOnce` 는 클로저의 *환경*라고 부르는, 클로저를 둘러싼
  환경에서 캡처한 변수를 사용합니다. 캡처한 변수를 사용하기 
  위해, 클로저는 해당 변수의 소유권을 가져야 하고 변수가 
  정의될 때 클로저 안으로 옮겨와야 합니다. `Once` 는 
  클로저가 동일한 변수의 소유권을 두 번 이상 가질 수 없으므로 
  한 번만 호출될 수 있다는 사실을 나타냅니다.
* `FnMut` 값들을 가변으로 빌려오기 때문에 환경을 변경할 수 있습니다.
* `Fn` 은 환경으로부터 값들을 불변으로 빌려 옵니다.

클로저를 만들 때 러스트는 클로저가 환경에 있는 값을 어떻게 
사용하는지에 따라 어느 트레잇을 사용할지 추론합니다. 모든 
클로저는 최소 한 번씩은 호출될 수 있기 때문에 `FnOnce` 를 
구현합니다. 캡처된 변수를 이동시키지 않는 클로저는 또한 `FnMut` 를, 
캡처된 변수를 가변 사용할 필요가 없는 클로저는 `Fn` 를 구현합니다. 
리스트 13-12 에서 `equal_to_x` 클로저의 몸통에서는 `x` 에 있는 값을 읽기만 
하면 되기 때문에 `x` 를 불변으로 빌립니다 (그래서 `equal_to_x` 은 `Fn` 트레잇입니다).

만약 클로저가 환경으로부터 사용하는 값에 대해 소유권을 갖도록 강제하고 싶다면,
파라미터 리스트 앞에 `move` 키워드를 사용할 수 있습니다. 이 기법은 클로저를
다른 스레드로 넘길 때 데이터를 이동시켜 새로운 스레드가 소유하도록 할 때 주로
유용합니다.

> 노트: `move` 클로저는 변수의 소유권을 넘겨받고 있더라도 여전히 `Fn` 또는 `FnMut` 를 
> 구현할 수도 있습니다. 이러한 이유는 클로저 타입으로 정의된 트레잇은 클로저가 어떻게
> 캡처하는 지가 아닌 캡처된 값을 갖고 무엇을 하는지에 따라 결정되기 때문입니다.
> `move` 키워드는 클로저가 어떻게 캡처하는지만 명시해주는 역할을 합니다.

16장에서 병렬성에 대한 부분에서 더 많은 `move` 클로저의 
예제가 있습니다. 우선은 변경된 리스트 13-12 의 코드를 
살펴봅시다. 클로저 정의에 `move` 키워드를 추가하고
정수는 이동되지 않고 복사되기 때문에 대신 벡터를 사용했습니다. 
이 코드는 아직 컴파일되지 않습니다:

<span class="filename">파일명: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch13-functional-features/no-listing-03-move-closures/src/main.rs}}
```

다음과 같은 에러가 발생합니다:

```console
{{#include ../listings/ch13-functional-features/no-listing-03-move-closures/output.txt}}
```

`move` 키워드를 추가했기 때문에 클로저가 정의될 때 `x` 
값은 클로저 안으로 이동됩니다. `x` 의 소유권은 클로저가 
갖게 되었고 `main` 은 더 이상 `println!` 문에서 `x` 를 
사용할 수 없습니다. `println!` 를 삭제하면 문제를 해결할 수 있습니다.

`Fn` 트레잇 바운드 중 하나를 기술할 때 대부분의 경우, `Fn` 으로 시작해보면
컴파일러는 클로저 몸통에서 어떻게 하는지에 따라 `FnMut` 혹은 `FnOnce` 이
필요한지 말해 줍니다.

환경을 캡처할 수 있는 클로저를 함수 파라미터로 유용한 상황을 설명하기 위해 
다음 주제인 반복자로 넘어갑시다.
