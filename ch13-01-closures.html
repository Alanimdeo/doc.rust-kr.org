<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>클로저: 환경을 캡처할 수 있는 익명 함수 - The Rust Programming Language</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">The Rust Programming Language</a></li><li class="chapter-item expanded affix "><a href="foreword.html">들어가기에 앞서</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">소개</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> 시작해봅시다</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> 러스트 설치</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Cargo를 사용해봅시다</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> 추리 게임</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> 일반적인 프로그래밍 개념</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> 변수와 가변성</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> 데이터 타입</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> 함수</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> 주석</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> 흐름 제어문</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> 소유권 이해하기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> 소유권이 뭔가요?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> 참조자와 Borrow</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> 슬라이스(Slice)</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> 연관된 데이터를 구조체로 구조화하기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> 구조체 정의 및 인스턴트화</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> 구조체를 사용한 예제 프로그램</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> 메소드 문법</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> 열거형과 패턴 매칭</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> 열거형 정의하기</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> match 흐름 제어 구성</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> if let을 사용한 간결한 흐름 제어</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> 커져가는 프로젝트를 패키지, 크레이트, 모듈로 관리하기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> 패키지, 크레이트</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> 모듈을 정의하여 스코프 및 공개 여부 제어하기</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> 경로를 사용해 모듈 트리에서 항목 가리키기</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> use 키워드로 경로를 스코프 내로 가져오기</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> 별개의 파일로 모듈 분리하기</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> 일반적인 컬렉션</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> 벡터에 여러 값을 목록으로 저장하기</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> 문자열에 UTF-8 텍스트를 저장하기</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> 해쉬맵(hash map)에 서로 연관된 키와 값을 저장하기</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> 에러 처리</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> 복구 불가능한 에러에는 panic!!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Result와 함께하는 복구 가능한 에러</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic!이냐, panic!이 아니냐, 그것이 문제로다</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> 제네릭 타입, 트레잇, 라이프타임</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> 제네릭 데이터 타입</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> 트레잇으로 공통된 동작을 정의하기</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> 라이프타임으로 참조자의 유효성 검증하기</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> 자동화 테스트 작성하기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> 테스트 작성 방법</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> 테스트 실행 제어하기</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> 테스트 조직화</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> I/O 프로젝트: 커맨드 라인 프로그램 만들기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> 커맨드 라인 인자 받기</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> 파일 읽기</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> 모듈성과 에러 처리 향상을 위한 리팩토링</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> 테스트 주도 개발로 라이브러리 기능 개발하기</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> 환경 변수 사용하기</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> 표준 출력 대신 표준 에러로 에러 메세지 작성하기</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> 함수형 언어의 특성들: 반복자와 클로저</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html" class="active"><strong aria-hidden="true">13.1.</strong> 클로저: 환경을 캡처할 수 있는 익명 함수</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Processing a Series of Items with Iterators</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Improving Our I/O Project</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparing Performance: Loops vs. Iterators</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> More about Cargo and Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Customizing Builds with Release Profiles</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publishing a Crate to Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Smart Pointers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Using Box&lt;T&gt; to Point to Data on the Heap</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Treating Smart Pointers Like Regular References with the Deref Trait</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Running Code on Cleanup with the Drop Trait</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, the Reference Counted Smart Pointer</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; and the Interior Mutability Pattern</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Reference Cycles Can Leak Memory</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Fearless Concurrency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Using Threads to Run Code Simultaneously</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Using Message Passing to Transfer Data Between Threads</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Shared-State Concurrency</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Extensible Concurrency with the Sync and Send Traits</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Object Oriented Programming Features of Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Characteristics of Object-Oriented Languages</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Using Trait Objects That Allow for Values of Different Types</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Implementing an Object-Oriented Design Pattern</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns and Matching</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> All the Places Patterns Can Be Used</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Pattern Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Advanced Features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Unsafe Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Advanced Traits</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Advanced Types</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Advanced Functions and Closures</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Building a Single-Threaded Web Server</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Turning Our Single-Threaded Server into a Multithreaded Server</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Keywords</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operators and Symbols</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Derivable Traits</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - Useful Development Tools</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - Editions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - Translations of the Book</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - How Rust is Made and “Nightly Rust”</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="클로저-환경을-캡처할-수-있는-익명-함수"><a class="header" href="#클로저-환경을-캡처할-수-있는-익명-함수">클로저: 환경을 캡처할 수 있는 익명 함수</a></h2>
<p>러스트의 <em>클로저</em>는 변수에 저장하거나 다른 함수에 인자로 넘길 수 
있는 익명 함수입니다. 한 곳에서 클로저를 만들고 다른 문맥에서 
그것을 평가하기 위해 호출할 수 있습니다. 함수와 다르게 클로저는 
정의된 스코프에서 값을 캡처할 수 있습니다. 앞으로 클로저의 이러한 
기능이 코드 재사용과 동작 사용자 정의를 어떻게 가능케 하는지 살펴볼 
것입니다.</p>
<h3 id="클로저로-동작을-추상화하기"><a class="header" href="#클로저로-동작을-추상화하기">클로저로 동작을 추상화하기</a></h3>
<p>클로저를 나중에 실행하기 위해 저장하는 것이 유용한 상황에 대한 
예제로 시작해봅시다. 이 과정에서 클로저 문법과 타입 추론, 
트레잇에 관해 얘기합니다.</p>
<p>이런 가상의 상황을 생각해 봅시다: 우리는 맞춤 운동 계획을 생성하는 
앱을 만드는 스타트업에서 일합니다. 백엔드는 러스트로 작성되어 있고, 
운동 계획을 생성하는 알고리즘은 사용자의 나이, 체질량 지수, 선호 운동, 
최근 운동, 사용자가 설정한 운동 강도 등 여러 요소를 고려합니다. 
실제 알고리즘은 이 예제에서 그렇게 중요하지 않습니다. 중요한 것은 
이 계산에 몇 초씩이나 걸린다는 것입니다. 이 알고리즘을 우리가 필요할 
때 한 번만 호출하기를 원하고, 그래서 사용자가 필요 이상으로 기다리지 
않게 만들고 싶습니다.</p>
<p>우리는 Listing 13-1 에 보이는 <code>simulated_expensive_calculation</code> 
함수를 사용해서 이 가상의 알고리즘 호출을 시뮬레이션합니다. 이 함수는 
<code>calculating slowly...</code> 를 출력하고, 2초를 기다린 다음, 
인자로 넘어온 어떤 숫자든 돌려줍니다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug, PartialEq, Copy, Clone)]
</span><span class="boring">enum ShirtColor {
</span><span class="boring">    Red,
</span><span class="boring">    Blue,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Inventory {
</span><span class="boring">    shirts: Vec&lt;ShirtColor&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Inventory {
</span><span class="boring">    fn giveaway(&amp;self, user_preference: Option&lt;ShirtColor&gt;) -&gt; ShirtColor {
</span><span class="boring">        user_preference.unwrap_or_else(|| self.most_stocked())
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn most_stocked(&amp;self) -&gt; ShirtColor {
</span><span class="boring">        let mut num_red = 0;
</span><span class="boring">        let mut num_blue = 0;
</span><span class="boring">
</span><span class="boring">        for color in &amp;self.shirts {
</span><span class="boring">            match color {
</span><span class="boring">                ShirtColor::Red =&gt; num_red += 1,
</span><span class="boring">                ShirtColor::Blue =&gt; num_blue += 1,
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        if num_red &gt; num_blue {
</span><span class="boring">            ShirtColor::Red
</span><span class="boring">        } else {
</span><span class="boring">            ShirtColor::Blue
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let store = Inventory {
</span><span class="boring">        shirts: vec![ShirtColor::Blue, ShirtColor::Red, ShirtColor::Blue],
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let user_pref1 = Some(ShirtColor::Red);
</span><span class="boring">    let giveaway1 = store.giveaway(user_pref1);
</span><span class="boring">    println!(
</span><span class="boring">        &quot;The user with preference {:?} gets {:?}&quot;,
</span><span class="boring">        user_pref1, giveaway1
</span><span class="boring">    );
</span><span class="boring">
</span><span class="boring">    let user_pref2 = None;
</span><span class="boring">    let giveaway2 = store.giveaway(user_pref2);
</span><span class="boring">    println!(
</span><span class="boring">        &quot;The user with preference {:?} gets {:?}&quot;,
</span><span class="boring">        user_pref2, giveaway2
</span><span class="boring">    );
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 13-1: 실행시간이 약 2초 걸리는 가상의 계산을 대신하는
함수</span></p>
<p>다음은 이 예제에서 중요한 운동 앱의 일부를 담고 있는 <code>main</code> 
함수입니다. 이 함수는 사용자가 운동 계획을 요청할 때 앱이 
호출할 코드를 나타냅니다. 앱의 프론트엔드와의 상호작용은 
클로저 사용과 관련이 없기 때문에 프로그램에 대한 입력을 
나타내는 값을 하드코딩한 다음 결과를 출력할 것입니다.</p>
<p>필요한 입력들은:</p>
<ul>
<li>낮은 강도 운동을 원하는지 혹은 고강도 운동을 원하는지를 
나타내기 위해 사용자가 지정하는 <em>운동 강도 숫자</em></li>
<li>몇 가지 다양한 운동 계획들을 생성할 <em>임의의 숫자</em></li>
</ul>
<p>출력은 추천 운동 계획이 될 것입니다. Listing 13-2 는 
우리가 사용할 <code>main</code> 함수입니다.</p>
<p><span class="filename">파일이름: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn generate_workout(intensity: u32, random_number: u32) {
</span>    let expensive_closure = |num: u32| -&gt; u32 {
        println!(&quot;calculating slowly...&quot;);
        thread::sleep(Duration::from_secs(2));
        num
    };
<span class="boring">
</span><span class="boring">    if intensity &lt; 25 {
</span><span class="boring">        println!(&quot;Today, do {} pushups!&quot;, expensive_closure(intensity));
</span><span class="boring">        println!(&quot;Next, do {} situps!&quot;, expensive_closure(intensity));
</span><span class="boring">    } else {
</span><span class="boring">        if random_number == 3 {
</span><span class="boring">            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);
</span><span class="boring">        } else {
</span><span class="boring">            println!(
</span><span class="boring">                &quot;Today, run for {} minutes!&quot;,
</span><span class="boring">                expensive_closure(intensity)
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let simulated_user_specified_value = 10;
</span><span class="boring">    let simulated_random_number = 7;
</span><span class="boring">
</span><span class="boring">    generate_workout(simulated_user_specified_value, simulated_random_number);
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 13-2:<code>main</code> 함수와 사용자 입력과 임의의 숫자 생성을 시뮬레이션
하기 위한 하드코딩된 값</span></p>
<p>단순함을 위해서 <code>simulated_user_specified_value</code> 변수의 
값을 10으로 하고 <code>simulated_random_number</code> 변수의 값을 
7로 하드코딩 했습니다. 실제 프로그램에서는 운동 강도를 프론트엔드에서 
전달받고 2장의 추리 게임에서처럼 난수 생성을 위해 <code>rand</code> 크레이트를 
사용할 것입니다. <code>main</code> 함수는 <code>generate_workout</code> 함수를 
모의의 입력값으로 호출합니다.</p>
<p>이제 상황이 만들어졌으니, 알고리즘으로 넘어가겠습니다. Listing 13-3 
에 있는 <code>generate_workout</code> 함수는 이 예제에서 가장 신경 써야 
할 앱의 비즈니스 로직을 포함하고 있습니다. 이 예제에서 나머지 코드 
변경 사항은 이 함수에 적용됩니다:</p>
<p><span class="filename">파일이름: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let example_closure = |x| x;

    let s = example_closure(String::from(&quot;hello&quot;));
    let n = example_closure(5);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 13-3: 입력값과 <code>simulated_expensive_calculation</code> 함
수 호출에 따라 운동 계획을 출력하는 비즈니스 로직</span></p>
<p>Listing 13-3 의 코드는 느린 계산 함수를 여러 번 호출합니다.
첫 번째 <code>if</code> 블록은 <code>simulated_expensive_calculation</code> 함수를 두 번 호출하고,
바깥 <code>else</code> 의 안쪽에 있는 <code>if</code> 문에서는 전혀 호출하지 않으며, 두 번째 <code>else</code> 문
의 경우는 한 번 호출합니다.</p>
<p><code>generate_workout</code> 함수의 바람직한 동작은 먼저 사용자가 
저강도 운동(25보다 작은 수로 표시) 혹은 고강도 운동(25 이상의 
수)을 원하는지 판단하는 것입니다.</p>
<p>저강도 운동 계획은 우리가 시뮬레이션 하는 복잡한 알고리즘에 따라 팔굽혀펴기와
윗몸일으키기의 횟수를 추천합니다.</p>
<p>사용자가 고강도 운동을 원한다면, 약간의 추가 로직이 있습니다: 
앱에서 생성된 난수값이 3인 경우, 앱은 휴식과 수분 섭취를 추천합니다. 
그렇지 않은 경우, 사용자는 복잡한 알고리즘을 기반으로 선택된 시간(분) 
동안 달리기를 하도록 안내받습니다.</p>
<p>현재 코드는 우리가 원하는 대로 동작하고 있습니다. 하지만 한번 데이터 사이언스 팀이 
앞으로 <code>simulated_expensive_calculation</code> 함수를 호출하는 방식을 바꾸기로 
결정했다고 생각해 봅시다.
이러한 변경이 발생했을 때 업데이트를 단순화하기 위해서, 이 코드를 리팩토링하여 
<code>simulated_expensive_calculation</code> 함수를 딱 한 번만 호출하도록 하려고
합니다. 또한 현재 해당 함수를 같은 값을 인자로 해서 불필요하게 두 번 호출하는 
부분도 없애고 싶습니다. 즉, 결과가 필요 없다면 함수를 호출하고 싶지 않고, 
필요하더라도 딱 한 번만 호출하고 싶습니다.</p>
<h4 id="함수를-사용해서-리팩토링하기"><a class="header" href="#함수를-사용해서-리팩토링하기">함수를 사용해서 리팩토링하기</a></h4>
<p>우리는 여러 방법으로 운동 프로그램을 재구성할 수 있습니다. 우선, Listing 13-4 에 
보이는 것처럼 중복된 <code>simulated_expensive_calculation</code> 함수 호출을 
하나의 변수로 추출해 볼 것입니다:</p>
<p><span class="filename">파일이름: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let list = vec![1, 2, 3];
</span><span class="boring">    println!(&quot;Before defining closure: {:?}&quot;, list);
</span><span class="boring">
</span><span class="boring">    let only_borrows = || println!(&quot;From closure: {:?}&quot;, list);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Before calling closure: {:?}&quot;, list);
</span><span class="boring">    only_borrows();
</span><span class="boring">    println!(&quot;After calling closure: {:?}&quot;, list);
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 13-4: <code>simulated_expensive_calculation</code> 에 대한
호출들을 한 곳으로 추출하고 결과를 <code>expensive_result</code> 변수에 저장하기</span></p>
<p>이 변경은 <code>simulated_expensive_calculation</code> 에 대한 모든 호출들을 
하나로 합치고 첫 번째 <code>if</code> 문에서 불필요하게 이 함수를 여러 번 호출하던 
문제를 해결합니다. 안타깝게도 이제 모든 경우에 대해서 이 함수를 호출하고 
결과를 기다리게 됩니다. 이 결과를 전혀 사용하지 않는 안쪽 <code>if</code> 블록의 
경우에도 이 함수 호출의 영향을 받게 됩니다.</p>
<p>우리는 프로그램에서 한 곳에서 코드를 정의하고, 실제로 결과가 필요한 곳에서만
그 코드를 <em>실행하고</em> 싶습니다. 이것이 클로저의 용례입니다.</p>
<h4 id="코드를-저장하기-위해-클로저를-사용해서-리팩토링하기"><a class="header" href="#코드를-저장하기-위해-클로저를-사용해서-리팩토링하기">코드를 저장하기 위해 클로저를 사용해서 리팩토링하기.</a></h4>
<p><code>if</code> 블록 전에 항상 <code>simulated_expensive_calculation</code> 함수를 
호출하는 대신, Listing 13-5에 보이는 것처럼 클로저를 정의하고 변수에 
함수 리턴 값을 저장하기보단 <em>클로저</em>를 저장할 수 있습니다. 
여기서 소개하는 것처럼 실제로 클로저 안에 <code>simulated_expensive_calculation</code> 
의 전체 내용을 옮길 수 있습니다.</p>
<p><span class="filename">파일이름: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let mut list = vec![1, 2, 3];
</span><span class="boring">    println!(&quot;Before defining closure: {:?}&quot;, list);
</span><span class="boring">
</span><span class="boring">    let mut borrows_mutably = || list.push(7);
</span><span class="boring">
</span><span class="boring">    borrows_mutably();
</span><span class="boring">    println!(&quot;After calling closure: {:?}&quot;, list);
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 13-5: 클로저를 정의하고 <code>expensive_closure</code> 변수에
저장하기</span></p>
<p>클로저 정의는 변수 <code>expensive_closure</code> 에 할당하기 위해 <code>=</code> 
다음에 옵니다. 클로저 정의는 수직의 파이프 (<code>|</code>) 한 쌍으로 시작하며, 
그 사이에는 매개변수를 적습니다; 이 문법은 스몰토크와 루비에서 클로저 
정의와 비슷하여 선택되었습니다. 이 클로저는 <code>num</code> 이라는 하나의 
매개변수를 갖습니다: 하나 이상의 매개변수를 갖는다면, <code>|param1, param2|</code> 
와 같이 콤마로 구분합니다.</p>
<p>매개변수 다음에는 클로저의 몸통을 포함하는 중괄호를 넣습니다. 클로저 
몸통이 하나의 표현식이면 중괄호는 선택 사항입니다. 중괄호 다음에 
클로저의 끝에는 <code>let</code>문을 완성하기 위해 세미콜론이 필요합니다. 클로저 
몸통에서 마지막 줄의 (<code>num</code>) 은 클로저가 호출되었을 때 클로저로부터 
반환되는 값입니다. 왜냐하면 해당 라인은 함수에서처럼 세미콜론으로 
끝나지 않기 때문입니다.</p>
<p><code>let</code> 문은 <code>expensive_closure</code> 가 익명함수의 <em>정의</em>를 포함하지, 
호출한 <em>결괏값</em>을 포함하지는 않는다는 것에 유의하세요. 우리가 클로저를 
사용하는 이유는 호출할 코드를 한 곳에서 정의하고 저장한 뒤에, 이후 
다른 곳에서 그것을 호출하길 원하기 때문이라는 것을 기억하세요; 우리가 
호출하고자 하는 코드는 이제 <code>expensive_closure</code> 에 저장되었습니다.</p>
<p>클로저를 정의한 후에는 <code>if</code> 블록 안의 코드는 클로저를 호출해서 결괏값을 
얻는 식으로 코드를 바꿀 수 있습니다. 함수를 호출하는 것처럼 클로저를 
호출합니다: Listing 13-6 에 보이는 것처럼, 클로저 정의를 저장하는 
변수명을 적고 다음엔 사용할 인자값을 포함하는 괄호가 따라옵니다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let list = vec![1, 2, 3];
</span><span class="boring">    println!(&quot;Before defining closure: {:?}&quot;, list);
</span><span class="boring">
</span><span class="boring">    thread::spawn(move || println!(&quot;From thread: {:?}&quot;, list))
</span><span class="boring">        .join()
</span><span class="boring">        .unwrap();
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 13-6: 우리가 정의한 <code>expensive_closure</code> 호출하기
</span></p>
<p>이제 비용이 큰 계산은 단 한 곳에서만 호출되고, 우리가 결과가 필요한 곳에서만
그 코드를 실행합니다.</p>
<p>그러나, 이는 Listing 13-3 에 있는 문제중 하나를 다시 야기하게 됩니다: 
우리는 여전히 첫 번째 <code>if</code> 블록에서 클로저를 두 번 호출 하는데, 
이는 비용이 큰 코드를 두 번 반복해서 호출하게 되면서 사용자는 두 배 
더 기다리게 됩니다. <code>if</code> 블록 안에 클로저 호출의 결과를 저장하는 
지역 변수를 만들어서 문제를 해결할 수도 있지만, 클로저는 다른 해결책을 
제공합니다. 그 해결책에 관해서는 조금 이따가 얘기하도록 하고 우선 
클로저 정의에 타입 어노테이션이 없는 이유와 클로저와 연관된 트레잇에 
관해 이야기 합시다.</p>
<h3 id="클로저-타입-추론과-어노테이션"><a class="header" href="#클로저-타입-추론과-어노테이션">클로저 타입 추론과 어노테이션</a></h3>
<p>클로저는 <code>fn</code> 함수처럼 파라미터나 반환 값의 타입을 명시할 것을 
요구하지 않습니다. 타입 어노테이션은 사용자에게 노출되는 명시적인 
인터페이스의 일부이기 때문에 함수에 필요합니다. 이 인터페이스를 
엄격하게 정의하는 것은 함수가 어떤 타입의 값을 사용하고 반환하는지에 
대해 모두가 합의한다는 것을 보장하는 데 중요합니다.
그러나 클로저는 이처럼 노출된 인터페이스에 사용되지 않습니다: 변수에 저장되고
이름 없이 우리의 라이브러리 사용자들에게 노출되지 않고 사용됩니다.</p>
<p>추가로, 클로저는 보통 짧고 임의의 시나리오 보다 좁은 문맥 
안에서만 관련이 있습니다. 이런 제한된 문맥 안에서만, 
컴파일러는 안정적으로 파라미터와 리턴타입을 추론할 수 있으며, 
이는 대부분의 변수 타입을 추론하는 방법과 비슷합니다.</p>
<p>프로그래머들에게 이런 작고 익명의 함수들에 타입을 달도록 하는 
것은 짜증이 나고 컴파일러가 이미 사용할 수 있는 정보와 
대개 중복됩니다.</p>
<p>변수와 마찬가지로 필요 이상으로 자세히 표현하는 비용을 지불하고서라도
명확성과 명료성을 높이고 싶다면 타입 어노테이션(혹은 타입 명시)를 추가할 수 있습니다.
Listing 13-5 에 정의한 클로저에 타입을 명시하는 것은 Listing 13-7 에 보이는 것과
같을 것입니다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut list = [
</span><span class="boring">        Rectangle { width: 10, height: 1 },
</span><span class="boring">        Rectangle { width: 3, height: 5 },
</span><span class="boring">        Rectangle { width: 7, height: 12 },
</span><span class="boring">    ];
</span><span class="boring">
</span><span class="boring">    list.sort_by_key(|r| r.width);
</span><span class="boring">    println!(&quot;{:#?}&quot;, list);
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 13-7: 클로저에 매개변수와 반환 값 타입에 대한 선택적
인 타입 어노테이션 추가하기</span></p>
<p>타입 어노테이션이 있으면 클로저와 함수의 문법은 더 비슷해 보입니다.
다음은 매개변수에 1을 더하는 함수 정의와 동일한 행위를 하는 클로저를 
수직으로 비교한 것입니다. 관련 있는 부분들을 같은 위치에 놓기 위해 
약간의 공백을 추가했습니다. 이것은 파이프를 사용하는 것과 선택적인 
문법의 양을 무시하고 클로저 문법과 함수 문법이 얼마나 비슷한지 보여줍니다:</p>
<pre><code class="language-rust ignore">fn  add_one_v1   (x: u32) -&gt; u32 { x + 1 }
let add_one_v2 = |x: u32| -&gt; u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;</code></pre>
<p>첫 번째 줄은 함수 정의를 보여주고, 두 번째 줄은 타입을 모두 
명기한 클로저 정의를 보여 줍니다. 세 번째 줄은 클로저 정의에서 
타입 어노테이션을 지웠고, 네 번째 줄은 선택적인 중괄호를 지웠는데, 
클로저 몸통이 단 하나의 표현식을 갖기 때문입니다.
이것은 모두 호출 했을 때 동일한 동작을 가지는 유효한 정의들입니다. 
<code>add_one_v3</code>와 <code>add_one_v4</code>의 경우에는 클로저 호출이 필요합니다. 
왜냐하면 어떻게 호출되는지에 따라 타입이 추론되기 때문입니다.</p>
<p>클로저 정의는 각각의 파라미터들과 반환 값에 대해 단 하나의 추론된 
구체적인 타입을 갖습니다. 예를 들면, Listing 13-8 은 파라미터로 
받은 값을 그대로 반환하는 짧은 클로저의 정의를 보여줍니다. 이 클로저는 
이 예제의 목적 외에는 유용하지 않습니다. 정의에 타입 어노테이션을 
추가하지 않았다는 것에 유의하세요: 클로저를 두 번 호출하는데, 
첫 번째는 <code>String</code> 을 인자로 사용하고 두 번째는 <code>u32</code> 를 사용한다면 
에러가 발생합니다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut list = [
</span><span class="boring">        Rectangle { width: 10, height: 1 },
</span><span class="boring">        Rectangle { width: 3, height: 5 },
</span><span class="boring">        Rectangle { width: 7, height: 12 },
</span><span class="boring">    ];
</span><span class="boring">
</span><span class="boring">    let mut sort_operations = vec![];
</span><span class="boring">    let value = String::from(&quot;by key called&quot;);
</span><span class="boring">
</span><span class="boring">    list.sort_by_key(|r| {
</span><span class="boring">        sort_operations.push(value);
</span><span class="boring">        r.width
</span><span class="boring">    });
</span><span class="boring">    println!(&quot;{:#?}&quot;, list);
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 13-8: 서로 다른 두 개의 타입으로 추론된 타입을 갖는 
클로저 호출해 보기</span></p>
<p>컴파일러는 이런 에러를 줍니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
error[E0507]: cannot move out of `value`, a captured variable in an `FnMut` closure
  --&gt; src/main.rs:18:30
   |
15 |     let value = String::from(&quot;by key called&quot;);
   |         ----- captured outer variable
16 |
17 |     list.sort_by_key(|r| {
   |                      --- captured by this `FnMut` closure
18 |         sort_operations.push(value);
   |                              ^^^^^ move occurs because `value` has type `String`, which does not implement the `Copy` trait

For more information about this error, try `rustc --explain E0507`.
error: could not compile `rectangles` due to previous error
</code></pre>
<p>처음 <code>String</code> 값으로 <code>example_closure</code> 을 호출하면, 컴파일러는 <code>x</code> 의 타입과
클로저의 반환 타입을 <code>String</code> 으로 추론합니다. 그다음부터 <code>example_closure</code>의 타입은 <code>String</code>
으로 고정되고, 같은 클로저를 다른 타입으로 사용하려고 할 때 타입 에러를 얻게 됩니다.</p>
<h3 id="제네릭-파라미터와-fn-트레잇을-사용하여-클로저-저장하기"><a class="header" href="#제네릭-파라미터와-fn-트레잇을-사용하여-클로저-저장하기">제네릭 파라미터와 <code>Fn</code> 트레잇을 사용하여 클로저 저장하기</a></h3>
<p>운동 생성 앱으로 돌아갑시다. Listing 13-6 에서, 우리의 코드는 
아직도 비용이 큰 계산을 수행하는 클로저를 필요보다 더 많이 호출 
합니다. 이 문제를 풀기 위한 한 가지 옵션은 비용이 많이 드는 
클로저의 결괏값은 재활용을 위해 변수에 저장하고 후에 결과가
필요한 부분에서 클로저를 다시 호출하는 대신 그 변수를 사용하는 것입니다.
그러나, 이 방법은 많은 반복된 코드를 만들 수 있습니다.</p>
<p>다행히도 다른 해결책이 있습니다. 우리는 클로저와 클로저를 
호출한 결괏값을 가진 구조체를 만들 수 있습니다. 그 구조체는 
결괏값을 필요할 때만 클로저를 호출할 것이며 그 결괏값을 
캐싱해둬서 나머지 코드에서 결과를 저장하고 재사용하지 않아도 
되도록 할 것입니다. 이 패턴을 <em>메모이제이션(memoization)</em> 
혹은 *지연 평가(lazy evaluation)*로 알고 있을 것입니다.</p>
<p>구조체에서 클로저를 갖고 있도록 하기 위해, 클로저 타입을 기술할 필요가 있는데,
구조체 정의는 각 필드의 타입을 알 필요가 있기 때문입니다. 각 클로저 인스턴스는
자신의 유일한 익명 타입을 갖습니다: 즉, 두 클로저가 동일한 시그니처를 갖더라도
그들의 타입은 여전히 다른 것으로 간주 됩니다. 클로저를 사용하는 구조체, 열거형,
함수 파라미터를 정의하기 위해, 10장에서 설명한 것처럼 제네릭과 트레잇 바운드를
사용합니다.</p>
<p><code>Fn</code> 트레잇은 표준 라이브러리에서 제공합니다. 모든 클로저는 
다음 트레잇 중 하나를 구현합니다: <code>Fn</code>, <code>FnMut</code>, 혹은 
<code>FnOnce</code>. <a href="#%ED%81%B4%EB%A1%9C%EC%A0%80%EB%A1%9C-%ED%99%98%EA%B2%BD-%EC%BA%A1%EC%B2%98-%ED%95%98%EA%B8%B0">&quot;클로저로 환경 캡처 하기&quot;</a>절에서 
이 트레잇들의 차이점들에 관한 설명할 것입니다; 이 예제에서 우리는 
<code>Fn</code> 트레잇을 사용할 수 있습니다.</p>
<p>클로저의 파라미터와 반환 값의 타입을 표현하기 위해 <code>Fn</code> 트레잇 
바운드에 타입을 추가합니다. 예제의 경우 클로저는 파라미터 타입이 
<code>u32</code>이고 <code>u32</code> 타입을 반환하므로, 명시하는 트레잇 바운드는 
<code>Fn(u32) -&gt; u32</code> 입니다.</p>
<p>Listing 13-9 는 클로저와 선택적인 결괏값을 가진 <code>Cacher</code> 구조체의 
정의를 보여줍니다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut list = [
</span><span class="boring">        Rectangle { width: 10, height: 1 },
</span><span class="boring">        Rectangle { width: 3, height: 5 },
</span><span class="boring">        Rectangle { width: 7, height: 12 },
</span><span class="boring">    ];
</span><span class="boring">
</span><span class="boring">    let mut num_sort_operations = 0;
</span><span class="boring">    list.sort_by_key(|r| {
</span><span class="boring">        num_sort_operations += 1;
</span><span class="boring">        r.width
</span><span class="boring">    });
</span><span class="boring">    println!(&quot;{:#?}, sorted in {num_sort_operations} operations&quot;, list);
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 13-9: <code>calculation</code> 에 클로저를 담고, 선택적인 결괏값을
<code>value</code> 에 담는 <code>Cacher</code> 구조체 정의하기</span></p>
<p><code>Cacher</code> 구조체는 제네릭 타입 <code>T</code> 의 <code>calculation</code> 필드를 갖습니다.
<code>T</code> 에 대한 트레잇 바운드는 <code>Fn</code> 트레잇을 사용하여 그것이 클로저라는 것을 나타냅니다. 
<code>calculation</code> 필드에 저장하고자 하는 클로저는 하나의 <code>u32</code> 타입 파라미터
(<code>Fn</code> 다음 괄호 안에 명시됨)를 갖고 <code>u32</code> (<code>-&gt;</code> 다음에 명시됨) 타입의 값을
반환해야 합니다.</p>
<blockquote>
<p>노트: 함수 또한 세 개의 <code>Fn</code> 트레잇을 모두 구현할 수 있습니다. 
환경에서 값을 캡처할 필요가 없다면, <code>Fn</code> 트레잇을 구현해야 
하는 클로저 대신 함수를 사용할 수 있습니다.</p>
</blockquote>
<p><code>value</code> 필드는 <code>Option&lt;u32&gt;</code> 타입입니다. 클로저를 실행하기 
전에 <code>value</code> 의 값은 <code>None</code> 입니다. <code>Cacher</code> 를 사용하는 
코드에서 클로저의 <em>결과</em> 를 요청할 경우, <code>Cacher</code> 는 그때 
클로저를 실행하고 결과를 <code>Some</code> variant에 넣어서 <code>value</code>
필드에 저장합니다. 그다음부터는 코드에서 클로저의 결과를 다시 요청하면 클로저를 다시 
실행하는 대신, <code>Cacher</code> 는 <code>Some</code> variant 안에 있는 결과를 돌려줍니다.</p>
<p>방금 설명한 <code>value</code> 필드에 대한 로직은 Listing 13-10 에 
정의되어 있습니다: </p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 13-10: <code>Cacher</code> 의 캐싱 로직</span></p>
<p>우리는 호출하는 코드에서 구조체 필드의 값을 변경할 수 있게 
만드는 것보다는 <code>Cacher</code> 가 값을 관리하도록 하고 싶기 
때문에, 필드는 비공개(private) 입니다.</p>
<p><code>Cacher::new</code> 함수는 제네릭 파라미터 <code>T</code> 를 받는데, 
<code>Cacher</code> 구조체와 동일한 트레잇 바운드를 갖도록 정의되었습니다. 
그다음 <code>Cacher::new</code> 는 <code>calculation</code> 필드에는 명시된 클로저를, 
<code>value</code> 필드에는 클로저를 아직 실행한 적이 없기 때문에 <code>None</code> 을 
갖는 <code>Cacher</code> 인스턴스를 반환합니다.</p>
<p>호출하는 코드에서 클로저를 평가한 결괏값을 원하면, 클로저를 
직접 호출하기보다 <code>value</code> 메서드를 호출합니다. 이 메서드는 
이미 <code>self.value</code> 에 결괏값을 <code>Some</code> 으로 가졌는지 
체크하고 만약 그렇다면 클로저를 다시 실행하는 대신 <code>Some</code> 안에 
있는 값을 반환합니다.</p>
<p>만약 <code>self.value</code> 가 <code>None</code> 이라면, <code>self.calculation</code> 에 
저장된 클로저를 호출하고, 나중에 재사용을 위해 결과를 <code>self.value</code> 에 
저장한 후 값을 반환합니다.</p>
<p>Listing 13-11 는 Listing 13-6 의 <code>generate_workout</code> 함수에서 <code>Cacher</code> 
구조체를 사용하는 방법을 보여줍니다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    for val in v1_iter {
        println!(&quot;Got: {}&quot;, val);
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 13-11: 캐싱 로직을 추상화하기 위해
<code>generate_workout</code> 함수 안에서 <code>Cacher</code> 사용하기</span></p>
<p>클로저를 변수에 직접 저장하는 대신, 클로저를 갖는 <code>Cacher</code> 의 
새 인스턴스를 저장했습니다. 그러고는, 결과가 필요한 각 위치에 
<code>Cacher</code> 인스턴스의 <code>value</code> 메소드를 호출했습니다. 우리는 
<code>value</code> 메소드를 원하는 만큼 호출할 수 있고, 전혀 호출하지 
않을 수도 있으며, 비싼 계산은 최대 한 번만 수행될 것입니다.</p>
<p>Listing 13-2 의 <code>main</code> 함수로 이 프로그램을 실행해 보세요. 
다양한 <code>if</code> 와 <code>else</code> 블록에 있는 모든 케이스를 검증하기 위해 
<code>simulated_user_specified_value</code> 와 <code>simulated_random_number</code> 
변수들을 변경해 보세요. <code>calculating slowly...</code> 메세지는 단 한 번만, 
그리고 필요할 때만 나타납니다. <code>Cacher</code> 는 <code>generate_workout</code> 가
비즈니스 로직에 집중할 수 있도록 비싼 계산을 필요한 것보다 더 호출하지 
않도록 보장하기 위한 로직을 처리합니다.</p>
<h3 id="cacher-구현의-제약사항"><a class="header" href="#cacher-구현의-제약사항"><code>Cacher</code> 구현의 제약사항</a></h3>
<p>값을 캐싱하는 것은 일반적으로 유용한 동작이기 때문에 다른 클로저와 함께 
코드의 다른 부분에서 사용하고 싶을 수도 있습니다. 그러나 현재 <code>Cacher</code>
구현은 다른 문맥에서 다르게 재사용하기에는 두 가지 문제가 있습니다.</p>
<p>첫 번째 문제는 <code>Cacher</code> 인스턴스가 <code>value</code> 메소드의 <code>arg</code> 
파라미터는 항상 같은 값을 얻는다는 가정을 한다는 것입니다. 
즉, 이 <code>Cacher</code> 테스트는 실패할 것입니다:</p>
<pre><code class="language-rust ignore panics">{{#rustdoc_include ../listings/ch13-functional-features/no-listing-01-failing-cacher-test/src/lib.rs:here}}</code></pre>
<p>이 테스트는 인자로 받은 값을 그대로 돌려주는 클로저가 포함된 새로운 <code>Cacher</code>
인스턴스를 생성합니다. <code>arg</code> 값을 1로 그리고 <code>arg</code> 값을 2로 해서 이 <code>Cacher</code>
인스턴스의 <code>value</code> 메소드를 호출하고, <code>arg</code> 값을 2로 <code>value</code> 를 호출 했을 때
2를 반환 할 것으로 기대합니다.</p>
<p>Listing 13-9 와 13-10 에 있는 <code>Cacher</code> 구현에 대해 이 테스트를 돌리면, 테스트는
다음과 같은 메시지와 함께 <code>assert_eq!</code> 에서 실패할 것입니다:</p>
<pre><code class="language-console">{{#include ../listings/ch13-functional-features/no-listing-01-failing-cacher-test/output.txt}}
</code></pre>
<p>문제는 처음 <code>c.value</code> 을 1로 호출 했을 때, <code>Cacher</code> 인스턴스는 <code>self.value</code> 에
<code>Some(1)</code> 을 저장합니다. 그 후에, <code>value</code> 값으로 무엇을 넘기던 메소드는 항상 1을 
반환할 것입니다.</p>
<p><code>Cacher</code> 가 하나의 값 대신 해시맵을 사용하도록 수정해 봅시다. 
해시맵의 키는 넘겨받은 <code>arg</code> 값이 될 것이고, 해시맵의 값은 
그 키로 클로저를 호출한 결과가 될 것입니다. <code>self.value</code> 가 
<code>Some</code> 혹은 <code>None</code> 값인지 직접 살펴보는 대신, <code>value</code> 함수는 
해시맵의 <code>arg</code> 값을 살펴보고 값이 있으면 반환할 것입니다.
값이 없으면, <code>Cacher</code> 는 클로저를 호출해서 해당 <code>arg</code> 값과 연관된 해시맵에
결괏값을 저장할 것입니다.</p>
<p>현재 <code>Cacher</code> 구현의 두 번째 문제는 <code>u32</code> 타입 파라미터 
한 개만 받고 하나의 <code>u32</code> 을 반환한다는 것입니다. 예를 들면, 
문자열 슬라이스를 넘겨주고 <code>usize</code> 값을 반환하는 클로저의 
결과를 캐시에 저장하고 싶을 수도 있습니다. 이 이슈를 수정하기 위해, 
<code>Cacher</code> 기능에 유연성을 높여주도록 더 제네릭한 파라미터를 사용해 봅시다.</p>
<h3 id="클로저로-환경-캡처하기"><a class="header" href="#클로저로-환경-캡처하기">클로저로 환경 캡처하기</a></h3>
<p>운동 생성 예제에서 우리는 클로저를 단지 인라인 익명 
함수로 사용했습니다. 그러나 클로저는 함수에 없는 
추가적인 능력을 갖추고 있습니다: 환경을 캡처해서
클로저가 정의된 스코프의 변수에 접근할 수 있습니다.</p>
<p>Listing 13-12 는 <code>equal_to_x</code> 변수에 저장된 클로저가 클로저를 둘러싼 환경에 있는 <code>x</code> 변수를
사용하는 예제를 보여줍니다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch13-functional-features/listing-13-12/src/main.rs}}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 13-12: 둘러싼 스코프에 있는 변수를 참조하는 클로저의
예</span></p>
<p>비록 <code>x</code> 가 <code>equal_to_x</code> 의 파라미터 중의 하나가 
아니더라도, <code>equal_to_x</code> 는 동일한 스코프에 정의된 
<code>x</code> 변수를 사용하는 것이 허용됩니다.</p>
<p>함수로는 이와 동일하게 할 수 없습니다; 다음 예제로 시도해 보면, 코드는 컴파일
되지 않습니다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch13-functional-features/no-listing-02-functions-cant-capture/src/main.rs}}</code></pre>
<p>에러가 발생합니다:</p>
<pre><code class="language-console">{{#include ../listings/ch13-functional-features/no-listing-02-functions-cant-capture/output.txt}}
</code></pre>
<p>컴파일러는 이것은 클로저에서만 동작한다고 상기시켜 주기까지 합니다!</p>
<p>클로저가 환경으로부터 값을 캡처할 때, 클로저 몸통에서 사용하기 위해 그 값을
저장하기 위한 메모리를 사용합니다. 이 메모리 사용은 환경을 캡처하지 않는 코드를
실행하길 원하는 더 흔한 상황에서는 지불하고 싶지 않은 오버헤드입니다.
왜냐하면 함수는 환경을 캡처할 수 없기 때문에, 함수를 정의하고 사용하는데
절대 이런 오버헤드는 발생하지 않습니다.</p>
<p>클로저는 세 가지 방식으로 환경으로부터 값을 캡처할 수 있는데, 
함수가 파라미터를 받는 세 가지 방식과 직접적으로 연결됩니다: 
소유권 받기, 가변으로 빌려오기, 불변으로 빌려오기. 이들은 
다음과 같이 세 가지의 <code>Fn</code> 트레잇으로 표현합니다:</p>
<ul>
<li><code>FnOnce</code> 는 클로저의 <em>환경</em>라고 부르는, 클로저를 둘러싼
환경에서 캡처한 변수를 사용합니다. 캡처한 변수를 사용하기 
위해, 클로저는 해당 변수의 소유권을 가져야 하고 변수가 
정의될 때 클로저 안으로 옮겨와야 합니다. <code>Once</code> 는 
클로저가 동일한 변수의 소유권을 두 번 이상 가질 수 없으므로 
한 번만 호출될 수 있다는 사실을 나타냅니다.</li>
<li><code>FnMut</code> 값들을 가변으로 빌려오기 때문에 환경을 변경할 수 있습니다.</li>
<li><code>Fn</code> 은 환경으로부터 값들을 불변으로 빌려 옵니다.</li>
</ul>
<p>클로저를 만들 때 러스트는 클로저가 환경에 있는 값을 어떻게 
사용하는지에 따라 어느 트레잇을 사용할지 추론합니다. 모든 
클로저는 최소 한 번씩은 호출될 수 있기 때문에 <code>FnOnce</code> 를 
구현합니다. 캡처된 변수를 이동시키지 않는 클로저는 또한 <code>FnMut</code> 를, 
캡처된 변수를 가변 사용할 필요가 없는 클로저는 <code>Fn</code> 를 구현합니다. 
Listing 13-12 에서 <code>equal_to_x</code> 클로저의 몸통에서는 <code>x</code> 에 있는 값을 읽기만 
하면 되기 때문에 <code>x</code> 를 불변으로 빌립니다 (그래서 <code>equal_to_x</code> 은 <code>Fn</code> 트레잇입니다).</p>
<p>만약 클로저가 환경으로부터 사용하는 값에 대해 소유권을 갖도록 강제하고 싶다면,
파라미터 리스트 앞에 <code>move</code> 키워드를 사용할 수 있습니다. 이 기법은 클로저를
다른 스레드로 넘길 때 데이터를 이동시켜 새로운 스레드가 소유하도록 할 때 주로
유용합니다.</p>
<blockquote>
<p>노트: <code>move</code> 클로저는 변수의 소유권을 넘겨받고 있더라도 여전히 <code>Fn</code> 또는 <code>FnMut</code> 를 
구현할 수도 있습니다. 이러한 이유는 클로저 타입으로 정의된 트레잇은 클로저가 어떻게
캡처하는 지가 아닌 캡처된 값을 갖고 무엇을 하는지에 따라 결정되기 때문입니다.
<code>move</code> 키워드는 클로저가 어떻게 캡처하는지만 명시해주는 역할을 합니다.</p>
</blockquote>
<p>16장에서 병렬성에 대한 부분에서 더 많은 <code>move</code> 클로저의 
예제가 있습니다. 우선은 변경된 Listing 13-12 의 코드를 
살펴봅시다. 클로저 정의에 <code>move</code> 키워드를 추가하고
정수는 이동되지 않고 복사되기 때문에 대신 벡터를 사용했습니다. 
이 코드는 아직 컴파일되지 않습니다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch13-functional-features/no-listing-03-move-closures/src/main.rs}}</code></pre>
<p>다음과 같은 에러가 발생합니다:</p>
<pre><code class="language-console">{{#include ../listings/ch13-functional-features/no-listing-03-move-closures/output.txt}}
</code></pre>
<p><code>move</code> 키워드를 추가했기 때문에 클로저가 정의될 때 <code>x</code> 
값은 클로저 안으로 이동됩니다. <code>x</code> 의 소유권은 클로저가 
갖게 되었고 <code>main</code> 은 더 이상 <code>println!</code> 문에서 <code>x</code> 를 
사용할 수 없습니다. <code>println!</code> 를 삭제하면 문제를 해결할 수 있습니다.</p>
<p><code>Fn</code> 트레잇 바운드 중 하나를 기술할 때 대부분의 경우, <code>Fn</code> 으로 시작해보면
컴파일러는 클로저 몸통에서 어떻게 하는지에 따라 <code>FnMut</code> 혹은 <code>FnOnce</code> 이
필요한지 말해 줍니다.</p>
<p>환경을 캡처할 수 있는 클로저를 함수 파라미터로 유용한 상황을 설명하기 위해 
다음 주제인 반복자로 넘어갑시다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch13-00-functional-features.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch13-02-iterators.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch13-00-functional-features.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch13-02-iterators.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </body>
</html>
